
\writestatus{loading}{Go/WeiQi/Baduk Lua module}


\startluacode

EMPTY = 0
BLACK = 1
WHITE = 2
ONSTACK = 4
DEAD = 5

Board = { Size = 19, LastColor = WHITE, MoveNumber = 0, Label = {}; {}}

Big = { Board = 15, Grid = 0.7, Stone = 14.5, Label = 0.9 }		--> Big sized goban 
Medium = { Board = 12, Grid = 0.5, Stone = 11.5, Label = 0.7 }	--> Medium sized goban
Small = { Board = 10, Grid = 0.4, Stone = 9.5, Label = 0.55 }	 	--> Small sized goban

Unit = Medium

Hoshi19 = {{x=4, y=4}, {x=4, y=10}, {x=4, y=16}, {x=10, y=4}, {x=10, y=10}, {x=10, y=16}, {x=16, y=4}, {x=16, y=10},{x=16, y=16}}
Hoshi13 = {{x=4, y=4}, {x=4, y=10}, {x=10, y=4}, {x=10, y=10}, {x=7, y=7}}
Hoshi9 = {{x=3, y=3}, {x=3, y=7}, {x=7, y=3}, {x=7, y=7}, {x=5, y=5}}

Hoshi = Hoshi19


function stone (x, y, c)	--> x, y: number; c: string (color: white or black)
	tex.sprint("fill fullcircle scaled " .. Unit.Stone .. " shifted (" .. x*Unit.Board .. "," .. y*-Unit.Board .. ") withcolor " .. c .. " ;")
	tex.sprint("draw fullcircle scaled " .. Unit.Stone .. " shifted (" .. x*Unit.Board .. "," .. y*-Unit.Board .. ") withcolor black ;")
end


function circlemarker (x, y, c)
	tex.sprint("draw fullcircle scaled " .. 0.6*Unit.Stone .. " shifted (" .. x*Unit.Board .. "," .. y*-Unit.Board .. ") withpen pencircle scaled (" .. 2*Unit.Grid .. ") withcolor " .. c .. " ;")
end


function label (l, x, y, c)
	tex.sprint("label(textext(\"\\color[" .. c .. "]{\\ss " .. l .. "}\"),(" .. x*Unit.Board .. ',' .. y*-Unit.Board .. '))  ;')
end


function draw_goban ()
	for i=1, Board.Size do
		tex.sprint("draw (" .. Unit.Board .. "," .. i*-Unit.Board .. ") -- (" .. Board.Size*Unit.Board .. "," .. i*-Unit.Board .. ") withpen pencircle scaled " .. Unit.Grid .. " ;")
		tex.sprint("draw (" .. i*Unit.Board .. "," .. -Unit.Board .. ") -- (" .. i*Unit.Board .. "," .. Board.Size*-Unit.Board .. ") withpen pencircle scaled " .. Unit.Grid .. " ;")
	end

	tex.sprint("draw (" .. Unit.Board .. "," .. -Unit.Board .. ") -- (" .. Board.Size*Unit.Board .. "," .. -Unit.Board ..") -- (" .. Board.Size*Unit.Board .. "," .. Board.Size*-Unit.Board .. ") -- (" .. Unit.Board .. "," .. Board.Size*-Unit.Board .. ") -- cycle withpen pencircle scaled (" ..2.5*Unit.Grid .. ") ;")

	for i=1, #Hoshi do
		x = Hoshi[i].x; y = Hoshi[i].y
		tex.sprint("drawdot (" .. x*Unit.Board .. "," .. y*-Unit.Board .. ") withpen pencircle scaled (" .. 5*Unit.Grid .. ") ;")
	end
end


function draw_stones ()
--	tex.sprint("defaultfont := \"ss\" ;") 			--> better will be to use Helvetica from TeX Gyre
	tex.sprint("defaultscale := " .. Unit.Label .. " ;")

	local index
	for i=1, Board.Size do
		for j=1, Board.Size do
			if Board[i][j] == BLACK then stone(i, j, "black") elseif Board[i][j] == WHITE then stone(i, j, "white") end
			if Board.Label[i][j] > 0 then
				if Board[i][j] == BLACK then
					label(Board.Label[i][j], i, j, "white")
				elseif Board[i][j] == WHITE then
					label(Board.Label[i][j], i, j, "black")
				end
			elseif Board.Label[i][j] < 0 then
				if Board[i][j] == BLACK then circlemarker(i, j, "white") else circlemarker(i, j, "black") end
			end
		end
	end
end


function display_board(name, size, p1, p2)
	tex.sprint("\\startuseMPgraphic{" .. name .. "}{}")
	tex.sprint("path p ;")

	draw_goban()
	draw_stones()

	if p1 then
		local x1, y1 = Point(p1)
		local x2, y2 = Point(p2)
		tex.sprint("p:= (" .. (x1-1)*Unit.Board .. "," .. (y1-1)*-Unit.Board ..") -- (" .. x2*Unit.Board .. "," .. (y1-1)*-Unit.Board .. ") -- (" .. x2*Unit.Board .. "," .. y2*-Unit.Board .. ") -- (" .. (x1-1)*Unit.Board .. "," .. y2*-Unit.Board .. ") -- cycle ;")
		tex.sprint("clip currentpicture to p shifted (" .. Unit.Board/2 .. "," .. -Unit.Board/2 .. ") ;")
	end

	tex.sprint("\\stopuseMPgraphic")
	tex.sprint("\\useMPgraphic{" .. name .. "}")
end


function set_stone (p, c)		--> c = "black", "white" or "empty" (AB, AW, AE)
	local x, y = Point(p)
	if c == "black" then
		Board[x][y] = BLACK 
	elseif c == "white" then
		Board[x][y] = WHITE
	elseif c == "empty" then
		Board[x][y] = EMPTY
	end
end


function Point (p)
	local x, y = 0, 0
	local l = "abcdefghijklmnopqrstuvwxyz"
	x = string.find(l, string.sub(p, 1, 1))
	y = string.find(l, string.sub(p, 2, 2))
	return x, y
end


function set_marker (p)
	local x, y = Point(p)
	if Board[x][y] > 0 then Board.Label[x][y] = -1 end
end


function play_move (p, c)		--> if p not defined -> pass
	Board.MoveNumber = Board.MoveNumber + 1	
	if c then
		if c == "white" then Board.LastColor = WHITE else Board.LastColor = BLACK end
	else
		if Board.LastColor == BLACK then Board.LastColor = WHITE else Board.LastColor = BLACK end
	end
	if p then
		local x, y = Point(p)
		Board[x][y] = Board.LastColor
		Board.Label[x][y] = Board.MoveNumber
		testDeadStones(x, y)
	end
end


function reset_board (s)
	if s == "small" then
		Board.Size = 9
		Hoshi = Hoshi9
	elseif s == "medium" then
		Board.Size = 13
		Hoshi=Hoshi13
	else
		Board.Size = 19
		Hoshi = Hoshi19
	end
	Board.LastColor = WHITE
	Board.MoveNumber = 0
	for i=1, Board.Size do
		Board [i] = {}
		Board.Label [i] = {}
		for j=1, Board.Size do
			Board[i][j] = EMPTY 
			Board.Label[i][j] = EMPTY
		end
	end
end


function reset_labels ()
	Board.MoveNumber = 0
	for i=1, Board.Size do
		for j=1, Board.Size do
			Board.Label[i][j] = EMPTY
		end
	end
end

---------------------------------------------------------
--- Deadstone calculator
---------------------------------------------------------

--- Stack implementation for deadstone calculator

function resetStack ()
	stack = {}
end

function push (x, y)
	if stack.next then
		local rec = {}
		rec.next = stack.next
		rec.x = x
		rec.y = y
		stack.next = rec
	else
		stack.next = {}
		stack.next.x = x
		stack.next.y = y
	end
end

function pop ()
	if stack.next then
		local x, y = stack.next.x, stack.next.y
		stack.next = stack.next.next
		return x, y
	end
end


--- Deadstone calculator

--- Are x, y valid coordinates? 

function isValid (x, y)
	if x >= 1 and x <= Board.Size and y >= 1 and y <= Board.Size then return true end
	return false
end

--- Reset shadow Goban

shadowboard = {}

function resetshadowboard (size)
	for i = 1, size do
		shadowboard[i] = {}
	end
end

--- Na základě stínového gobanu odstraní kameny označené jako mrtvé ze skutečného gobanu.

function removedeadstones ()
	for i, k in pairs(shadowboard) do
		for j, v in pairs(k) do Board[i][j] = EMPTY end
	end
end

--- Test, je-li x, y prázdná.
-- V opačném případě je-li na x, y soupeřův kámen, uloží do zásobníku jeho pozici.

function isEmpty (x, y)
	if Board[x][y] == EMPTY then
		return true
	elseif Board[x][y] ~= myColor and shadowboard[x][y] ~= DEAD then
		push(x,y)
	end
	return false
end

--- Testuje, zda má kámen na pozici x, y svobodu.
-- V případě že ne, vrací true, jinak false.

function isDead (x, y)
	if isValid(x, y+1) and isEmpty(x, y+1) then return false end
	if isValid(x-1, y) and isEmpty(x-1, y) then return false end
	if isValid(x, y-1) and isEmpty(x, y-1) then return false end
	if isValid(x+1, y) and isEmpty(x+1, y) then return false end
	return true
end

--- Test na mrtvou skupinu.
-- V případě že skupina, jejíž součástí je kámen na pozici x, y je mrtvá,
-- odstraní ji z gobanu. Může být použito na test sebevraždy.

function deadstones (x, y)
	resetStack()
	resetshadowboard(Board.Size)
	while isDead(x, y) do
		shadowboard [x][y] = DEAD
		x, y = pop()
		if x then
		else
			removedeadstones()
			break
		end
	end
end

--- Testuje právě umístěný kámen, jestli nebere soupeře.
-- Pro každý sousední soupeřův kámen spouští test na mrtvou skupinu.

function testDeadStones (x, y)
	myColor = Board[x][y]
	if isValid(x+1,y) and Board[x+1][y] ~= EMPTY and Board[x+1][y] ~= myColor then deadstones(x+1, x) end
	if isValid(x,y+1) and Board[x][y+1] ~= EMPTY and Board[x][y+1] ~= myColor then deadstones(x, y+1) end
	if isValid(x-1,y) and Board[x-1][y] ~= EMPTY and Board[x-1][y] ~= myColor then deadstones(x-1, y) end
	if isValid(x,y-1) and Board[x][y-1] ~= EMPTY and Board[x][y-1] ~= myColor then deadstones(x, y-1) end
end

\stopluacode

\def\move#1%
	{\ctxlua{play_move("#1")}}

%\def\move
%	{\dosingleargument\domove}

%\def\domove[#1]{#2}
%	{\iffirstargument
%		\ctxlua{play_move("#2", "#1")}
%	\else
%		\ctxlua{play_move("#2")}
%	\fi}

\def\pass
	{\ctxlua{play_move()}}

\def\stone[#1]#2%
	{\ctxlua{set_stone("#2", "#1")}}

\def\marker#1%
	{\ctxlua{set_marker("#1")}}

\def\newboard
	{\dosingleargument\donewboard}

\def\donewboard[#1]%
	{\iffirstargument
		\ctxlua{reset_board("#1")}
	\else
		\ctxlua{reset_board("big")}
	\fi}

\def\resetnumbering
	{\ctxlua{reset_labels()}}

\def\drawboard
	{\dosingleargument\dodrawboard}

	

\def\dodrawboard[#1]%
	{\iffirstargument
		\ctxlua{display_board(0, "#1")}
	\else
		\ctxlua{display_board(0, "medium")}
	\fi}



\def\drawpartialboard#1#2%
	{\ctxlua{display_board(0, "medium", "#1", "#2")}}


\starttext

\newboard[medium]
\stone[black]{bb}
\stone[black]{cb}
\marker{cb}
\stone[black]{eb}
\stone[white]{bc}
\stone[white]{bd}
\marker{bd}
\stone[white]{dd}
\stone[white]{dc}
\stone[empty]{dd}
\stone[black]{hb}
\stone[black]{fc}
\stone[white]{ch}

\stone[black]{id}
\stone[black]{hd}
\stone[white]{gd}
\stone[white]{fb}
\stone[black]{jb}
\stone[black]{kd}
\stone[black]{jj}
\stone[white]{kh}
\drawpartialboard{gg}{mm}
\drawboard

\move{gb}
\move{ec}
\move{fa}
\move{db}
\move{da}
\drawboard

\newboard  % [big]
\move{dp}
\move{cn}
\move{fp}
\move{bp}
\move{cq}
\move{ck}
\move{jq}
\drawboard

\pass
\move{pd}

\resetnumbering
\marker{pd}
\move{nc}
\move{qf}
\move{jd}
\drawpartialboard{da}{sh}
\drawboard

\newboard
\stone[black]{dd}
\stone[black]{de}
\stone[black]{ef}
\stone[black]{ff}
\stone[black]{ge}
\stone[black]{gd}
\stone[black]{gc}
\stone[black]{gb}
\stone[black]{ga}
\stone[black]{cc}
\stone[black]{aa}
\stone[black]{ac}
\stone[black]{ad}
\stone[black]{ae}
\stone[black]{bf}
\stone[black]{cf}
\stone[black]{dc}
\stone[black]{ab}
\stone[black]{df}

\stone[white]{ba}
\stone[white]{bc}
\stone[white]{bd}
\stone[white]{ca}
\stone[white]{da}
\stone[white]{ea}
\stone[white]{fa}
\stone[white]{cb}
\stone[white]{cd}
\stone[white]{db}
\stone[white]{eb}
\stone[white]{fb}
\stone[white]{ec}
\stone[white]{fc}
\stone[white]{ed}
\stone[white]{fd}
\stone[white]{ee}
\stone[white]{fe}
\stone[white]{be}
\stone[white]{ce}

\drawboard
\move{bb}
\drawboard


\stoptext
